<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缓存分类大全</title>
    <link href="/2024/07/02/%E7%BC%93%E5%AD%98%E5%88%86%E7%B1%BB%E5%A4%A7%E5%85%A8/"/>
    <url>/2024/07/02/%E7%BC%93%E5%AD%98%E5%88%86%E7%B1%BB%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021702376.jpeg" alt="img"></p><p>缓存（Cache）是一种存储技术，可以存储数据，以便快速获取数据。缓存最重要的是两个特性：存储、快速获取。缓存的本质：「用空间换时间」，用快速存储的介质保存数据，以提升数据访问的速度。</p><p>在计算机的世界里，缓存被广泛应用于硬件（如 CPU 高速缓存、寄存器）和软件中（如浏览器缓存、CDN、应用程序中的缓存等）。</p><p><strong>后台中的缓存</strong></p><p>后台开发中，缓存的使用场景一般有：</p><ul><li><strong>提升接口响应速度：</strong>缓存相比 IO 请求、数据库查询速度要快得多，适当使用缓存提升响应速度</li><li><strong>降低数据源服务的负载压力：</strong>将需要高并发读取的数据缓存起来，当相同请求进来时返回缓存数据，减轻数据源服务（如数据库、上游系统）的负载压力</li><li><strong>减少计算资源的浪费：</strong>将需要复杂且耗时计算的结果缓存起来，减少相同请求导致的重复计算资源浪费</li></ul><h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1><p>缓存策略通常分为两种，通读缓存和旁路缓存。</p><h2 id="1-1-通读（read-through）缓存"><a href="#1-1-通读（read-through）缓存" class="headerlink" title="1.1 通读（read-through）缓存"></a>1.1 通读（read-through）缓存</h2><p>在使用通读缓存时，应用程序会尝试从缓存中获取数据。如果该数据已存在于缓存中，那么缓存会直接返回该数据。若缓存中并未包含所需数据，那么缓存会自行访问数据源来获取数据，并将获取的数据返回给应用程序，同时将这份数据保存在缓存中。如此一来，当应用程序下次需要同样的数据时，就能够直接从 read-through 缓存中获取，无需再次访问数据源。</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021637672.png" alt="图片"></p><p>通读缓存的应用有很多，比如 CDN：</p><blockquote><p>CDN（Content Delivery Network）即内容分发网络，是一种分布式的网络架构。依赖于服务商提供的广泛分布于各地的 CDN 服务器，通过把数据分发并缓存到各地的 CDN 服务器上，当用户请求数据时，CDN 会匹配离用户距离最近的节点并返回缓存数据，以此来提高用户访问资源的速度。CDN 一般用来加速静态资源的传输，比如图片、CSS、HTML 等内容。而动态的内容，如搜索结果、单据信息等则不合适，这类数据需要应用服务器实时计算后才能返回。</p></blockquote><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021640286.png" alt="图片"></p><h2 id="1-2-旁路（cache-aside）缓存"><a href="#1-2-旁路（cache-aside）缓存" class="headerlink" title="1.2 旁路（cache-aside）缓存"></a>1.2 旁路（cache-aside）缓存</h2><p>与通读缓存不同，旁路缓存不直接与数据源打交道。应用程序尝试从旁路缓存获取数据，如果数据不存在，则返回空。应用程序自行请求数据源获取数据，并写入旁路缓存。这样下次相同的请求到达时，应用程序从旁路缓存中则会获取到数据。</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021641827.png" alt="图片"></p><p>通读缓存和旁路缓存这两种策略，一般来说都会灵活应用、互相包含。比如通读缓存中，对数据的查询和写缓存，使用的就是旁路缓存策略。而该实现被整体封装起来，对外表现的则是通读缓存策略。</p><p>在后台服务中，缓存的类型可以分为本地缓存和分布式缓存。</p><h1 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h1><h2 id="2-1-本地缓存（local-cache）"><a href="#2-1-本地缓存（local-cache）" class="headerlink" title="2.1 本地缓存（local cache）"></a>2.1 本地缓存（local cache）</h2><p>本地缓存，与应用程序的进程有相同的生命周期，存放于应用程序的堆空间（heap）中。</p><ul><li><p>优势：</p><p>使用简单；无外部依赖；读取速度快（无网络 IO 请求）；</p></li><li><p>缺点：</p><p>空间小：应用程序的服务器资源有限，所以本地缓存的空间小；分布式一致性问题：如果后台服务是分布式架构的，那么不同的服务实例之间的本地缓存可能会有差异；无法持久化：本地缓存会随着进程结束而被销毁，无法持久化。</p></li></ul><h2 id="2-2-分布式缓存（remote-cache）"><a href="#2-2-分布式缓存（remote-cache）" class="headerlink" title="2.2 分布式缓存（remote cache）"></a>2.2 分布式缓存（remote cache）</h2><p>分布式缓存，也可理解为远端缓存。使用外部的缓存服务，独立部署，与应用程序解藕。</p><ul><li><p>优势：</p><p>空间充足：外部存储一般空间都很充足；无分布式一致性问题：不同的服务实例连接同一个缓存服务，不存在一致性问题；主流的分布式缓存，如 redis，支持数据持久化和恢复，当缓存服务挂了可以恢复数据。</p></li><li><p>缺点：</p><p>引入外部依赖、需要部署和运维单独的缓存服务。</p></li></ul><h1 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h1><p>由于缓存的空间是有限的，如果缓慢的空间被使用完了，则需要淘汰旧的数据，腾出空间给新的数据使用。缓存淘汰常用的几种策略有如下几种。</p><h2 id="3-1-FIFO（First-In-First-Out）算法"><a href="#3-1-FIFO（First-In-First-Out）算法" class="headerlink" title="3.1 FIFO（First In First Out）算法"></a>3.1 FIFO（First In First Out）算法</h2><p>FIFO 算法是最简单最好理解的，其策略是：先进先出，如果一个数据的写入时间越早，说明将来被访问的几率越低。因此 FIFO 算法优先淘汰最早写入的数据。</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021643891.png" alt="图片"></p><h2 id="3-2-LRU（Least-Recently-Used）算法"><a href="#3-2-LRU（Least-Recently-Used）算法" class="headerlink" title="3.2 LRU（Least Recently Used）算法"></a>3.2 LRU（Least Recently Used）算法</h2><p>LRU 算法，即最近最少使用算法。如果一个数据最近被访问了，那么将来被访问的几率越高。反之，如果一个数据很久都没有访问，那么将来被访问的几率越低。其淘汰策略就是：优先淘汰最久没有被使用到的数据。LRU 通常使用双向链表+哈希表来实现。</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021644612.png" alt="图片"></p><h2 id="3-3-LFU（Least-Frequently-Used）算法"><a href="#3-3-LFU（Least-Frequently-Used）算法" class="headerlink" title="3.3 LFU（Least Frequently Used）算法"></a>3.3 LFU（Least Frequently Used）算法</h2><p>LFU 算法，即最少使用算法。如果一个数据被访问的次数越多，那么将来被访问的几率越高。反之，如果一个数据被访问的次数越少，那么将来被访问的几率越小。其淘汰策略就是：优先淘汰最少被使用的数据。LFU 算法可以使用小顶堆+哈希表来实现。</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021645845.png" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2024/06/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2024/06/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇文章，我的b站账号是心流coding</p><p>我将会在此更新有关大厂面试，程序员技术栈等知识</p><p><img src="https://picgo-1326631670.cos.ap-guangzhou.myqcloud.com/202407021624270.png" alt="image-20240702162426072"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
